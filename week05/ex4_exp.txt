The first row shows the real time (in seconds) taken by each thread,
which includes the user and system times.
The second row shows the user time (in seconds) taken by each thread,
which excludes the system time.
The third row shows the system time (in seconds) taken by each thread,
which is the time spent in the kernel managing the thread.

As we can see from the results,
the real time taken by a program decreases as the number of threads increases.

However, the user time taken by each thread does not change much as the number of threads increases.
This suggests that the majority of the time is spent in user space, performing useful work,
rather than in system space, where the kernel is managing the thread.

The system time taken by each thread is growing fast, unlike in exercise 3,
indicating that the amount of switches between processes is increased. Therefore,
implementation in the 4th task would perform significantly worse then in the 3rd task, as m grows.
This way, we need to consider thread switching overhead when we design our concurrent solution. 